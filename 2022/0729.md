## スタックについて深掘り（メモリ）

### スタックとは

- データ構造の一種
- 特徴として、あるデータを格納できる箱みたいなものがあった時に、先に箱に詰めたデータよりも後に詰めたデータの方が早く除去されるといった構造を持つようなもののこと
- 調理場に重ねられた多くの皿に例えられることがある。皿が多く重なっていると、先に下に重ねた皿に比べて上に重ねられた皿を使うので

### スタックメモリの話

- 上述のスタックというデータ構造を、条件次第でメモリ上でも実現できる領域がある。それをスタックメモリとか、スタック領域とか、ヒープと退避して単にスタックと呼ばれることがあったり色々
- メモリは、限られたリソースなのでメモリを有効活用するためにも、必要なタイミングでメモリを使って、必要なら無くなったタイミングで除却されると良い。それを上述のスタック構造を持つメモリの領域内で自動で実現してくれるので嬉しいよねという話
- スタックは関数(ルーチン)内のローカル変数や関数の引数のような、一時的にメモリにあってすぐ無くなってほしいようなものに使われる。

### 実行時の仮想メモリアドレス空間の一般的な概念図

<img width="200" alt="スクリーンショット 2022-07-29 5 56 41" src="https://user-images.githubusercontent.com/16571394/181636052-f0453e58-f82f-4202-be6d-7d46e8bf6664.png">

https://kataware.hatenablog.jp/entry/2017/12/02/224444 にある下記添付の方がわかりやすいかな

<img width="200" alt="スクリーンショット 2022-07-29 6 21 41" src="https://user-images.githubusercontent.com/16571394/181639894-62881577-40f5-4763-a37c-3e5f04ae2389.png">


- ある実行バイナリを実行している際のあるプロセスの仮想メモリアドレス空間のイメージ図
- 機械語（関数の実行するコード）そのものも、メモリアドレス空間に展開された状態でその関数のポインタをipに指定して、インクリメントさせるような形で関数内部のアセンブリを実行している（レジスタの話とかしてないので本当にざっくり）
- 静的変数（多分機械語もそう）は、プロセスが終了するまで残り続ける https://github.com/takeshi-1000/my_memo/blob/main/2022/0726.md も参考
- 対してヒープ領域、スタック領域はどちらも動的にメモリに展開される際に使われる領域 https://github.com/takeshi-1000/my_memo/blob/main/2022/0726.md も参考
- ヒープ領域は、アプリケーションレベル（コンパイル前に渡すソースコードレベル）での制御をすることで動的に確保したり、解放したりすることが可能（mallocやfree）
- スタック領域は、アプリケーションレベルでの制御は無理。仮想メモリアドレスのスタックを制御するスタックポインタやベースポインタの値を格納する用のレジスタが用意されており、そのレジスタを機械語命令で制御して、確保や解放を行う。
（機械語命令自体はコンパイラが出力するので、そういった意味ではコンパイラのコードでスタック領域を制御していると言えそう？
あああ

ああ

### テストプログラムを用いたstackのメモリ展開イメージ, 実行イメージ

#### 1. 下記のファイルを準備

```
#include<stdio.h>

int square(int a, int b){
 int num = a * b;
 printf("%d\n", num);
}

int main(void){
        int a = 5;
        int b = 4;
        square(5, 4);
        return 0;
}
```

#### 2. デバッガ(gdb)を使用して、break point にmainとsquareにおいて実行

(小ネタ)

b main で、0x67f, b square で、0x64e, にそれぞれbreakpointを設定してくれたようだが、逆アセンブルした内容見るとどちらもスタック領域確保前のアセンブリの位置で止まる感じ

![スクリーンショット 2022-07-30 5 08 01](https://user-images.githubusercontent.com/16571394/181836165-2166616e-ef18-4d93-a581-2013f1278ad2.png)


#### 3. main(0x67f)で止まった際に確認

わかること

- ベースポインタ(RBP)、スタックポインタ(RSP)のアドレスは、0x7fffffffddd0である
- スタックは8byteで区切られているっぽい？

![スクリーンショット 2022-07-29 6 38 22](https://user-images.githubusercontent.com/16571394/181835183-e44bcf20-5c8a-4f17-ac29-b8faa0a4ab28.png)

#### 4. sub rsp, 0x10 を実行 in main

![スクリーンショット 2022-07-30 5 13 49](https://user-images.githubusercontent.com/16571394/181836598-fe5d7def-8ceb-4732-9473-00aba04b2d11.png)


わかること

- stackのアドレスが-16され、上部(低位アドレスの方)に拡張された(RBPは変わらず、RSPは0x7fffffffddc0)
- RIPは0x683を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する）


#### 5. mov DWORD PTR [rbp-0x8], 0x5 を実行 in main

![スクリーンショット 2022-07-30 5 23 39](https://user-images.githubusercontent.com/16571394/181837934-d18ab643-9a77-465b-8c37-6a5eb06f573d.png)

わかること

- stackを見ると、bpから0x-8されたところに、0x5が格納されてそう
・0008| 0x7fffffffddc8 --> 0x5 の箇所
・stak領域の大きさに変化はなし
- RIPは0x68aを指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 6. mov DWORD PTR [rbp-0x4], 0x4 を実行 in main

![スクリーンショット 2022-07-30 5 43 01](https://user-images.githubusercontent.com/16571394/181840296-55d440c9-c1b2-4fcc-88cf-da269c805d58.png)

わかること

- stack上では0x4の格納が確認できない。gdbの表示では8byte刻みでしか表示されてないので、その辺りを変更する方法を探す必要がありそう
・stak領域の大きさに変化はなし
- RIPは0x691を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 7. mov esi, 0x4を実行する in main

![スクリーンショット 2022-07-30 10 15 27](https://user-images.githubusercontent.com/16571394/181864734-45076dd5-1bbc-4b18-9c60-9b1612c6ec5c.png)

わかること

- rsi レジスタに、0x4が入っている（おそらく後ほど呼ばれるメソッドの引数として使用されるのだろう）
- stack領域の大きさに変化なし
- RIPは0x696を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 8. mov edi, 0x5を実行する in main

![スクリーンショット 2022-07-30 10 24 07](https://user-images.githubusercontent.com/16571394/181864979-fc036cf9-e29f-4123-99c2-bb71845ede12.png)

わかること

- rdi レジスタに、0x4が入っている（おそらく後ほど呼ばれるメソッドの引数として使用されるのだろう）
- stack領域の大きさに変化なし
- RIPは0x69bを指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する
- gdbの表示に、Guessed arguments として、argの配列が表示されている

#### 9. call 0x55555555464a (square) を実行する in main

![スクリーンショット 2022-07-30 10 27 04](https://user-images.githubusercontent.com/16571394/181865107-0a133649-3882-487b-9d48-1bb461b3f945.png)

わかること

- 0x464a(push rbp), 0x46b(mov rbp, rsp) を実行された状態で、ブレークポイントが止まってくれた(スタックに詰むところまでやってくれた)
- n コマンドで進むと、1命令ずつ読んでくれていたので、squareの一番先頭で止まってくれるかと思ったが、そういうのは無理らしい
- stack領域が拡張された(16バイト分低位アドレスへ)
・b0には何が？ -> main関数のアセンブリを実行していた際のrbpが格納されている
・b8には何が？ -> 0x46a0 これは、main関数でsquare関数を読んだ後に読み出されることが期待される命令のアドレス (画像1参照)
- このサイト https://kataware.hatenablog.jp/entry/2017/12/02/224444 の画像2の意味がわかる

(画像1)

![スクリーンショット 2022-07-30 10 44 53](https://user-images.githubusercontent.com/16571394/181865518-d729a8b7-50ed-488e-9cb1-4544f7a6b12a.png)

(画像2)

![スクリーンショット 2022-07-30 10 48 20](https://user-images.githubusercontent.com/16571394/181865681-ea12e48f-2703-48e3-a32f-0b84e8ae5db7.png)

- rbpはどのように変わった？ 0xd0 -> 0xb0 (32バイト低位アドレスへ)
- rspはどのように変わった？ 0xc0 -> 0xb0 (16バイト低位アドレスへ)
- 上記からまだrbp/rspの位置は同じっぽい
- RIPは0x64eを指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 10. sub rsp 0x20 を実行 in square

![スクリーンショット 2022-07-30 11 06 10](https://user-images.githubusercontent.com/16571394/181866186-8ac232e1-dd02-4ed6-bd7e-235e837b78bf.png)

わかること

- stackが拡張された(32バイト分低位アドレスへ)
- stackが拡張されたので、rsp, rbp の値が変わった。rsp: 0x90, rbp: b0(これは変わってない)
- RIPは0x652を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 11. mov DWORD PTR [rbp-0x14], edi を実行 in square

![スクリーンショット 2022-07-30 11 17 31](https://user-images.githubusercontent.com/16571394/181866475-1e7c8fd2-852c-4a8c-966c-cf7415164147.png)

わかること

- 場所は、rbpから-20(0x14)バイト分らしいので、9cから4バイト分で入ってそうだが、0x98からの値的に何か矛盾してそう。何でかな

![スクリーンショット 2022-07-30 11 47 31](https://user-images.githubusercontent.com/16571394/181867299-3501caba-9585-461b-8a14-464ec2cb41af.png)


- stackの大きさに変化なし
- RIPは0x655を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 11. mov DWORD PTR [rbp-0x18], esi を実行 in square

![スクリーンショット 2022-07-30 11 26 54](https://user-images.githubusercontent.com/16571394/181866766-a91a4d6e-d211-488c-954d-23ad26a240ac.png)

わかること

- stackメモリ上に、esiの値が入っている。場所は、rbpから-24バイト分らしいので、添付のようになっている？
- stackの内容見ると、0x500000004となっていて、矛盾なさそう（リトルエンディアン的には、ちょっと違うのかも。）

![スクリーンショット 2022-07-30 11 53 59](https://user-images.githubusercontent.com/16571394/181867483-1f5e75ed-fed3-42c1-a600-3afb3d136653.png)

リトルエンディアン的に右の表がおそらく正しいし、それを読み取った結果が0x500000004となっているのかも

![スクリーンショット 2022-07-30 11 57 44](https://user-images.githubusercontent.com/16571394/181867615-36ff5a07-7e2a-4037-a4ea-316ff2f3d701.png)

- stackの大きさに変化なし
- RIPは0x658を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 12. mov eax, DWORD PTR [rbp-0x14] を実行 in square

![スクリーンショット 2022-07-30 12 08 43](https://user-images.githubusercontent.com/16571394/181870241-f82bac14-1863-4409-bed0-65a5625b14e1.png)

わかること

- raxレジスタに0x5が入っている
- stackに特に変化はなさそう
- DWORD PTR 云々は調べる必要がありそうだが、ベースポインタから20バイト低位アドレスに遡ったところのものをeaxに入れる感じかな(確かraxは64bitでeaxは32bitだっけか=int4バイト=32bitだし辻褄合うな)
- RIPは0x65bを指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する
- さっきの添付の表でいくと、raxには0x4が入ってそうなんだが、どういうことや
- stackの大きさに変化なし
- RIPは0x65bを指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 13. imul eax, DWORD PTR [rbp-0x18] を実行 in square

![スクリーンショット 2022-07-30 12 29 15](https://user-images.githubusercontent.com/16571394/181870819-e67b2c4d-458f-4f36-bd7d-922738b0e3b1.png)


わかること

- raxレジスタに、0x14が入っている（おそらく5*4の結果の20の16進数）
- stackの大きさに変化なし
- RIPは0x65fを指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 14. mov DWORD PTR [rbp-0x4], eax を実行 in square

![スクリーンショット 2022-07-30 12 40 18](https://user-images.githubusercontent.com/16571394/181871092-3a3b22ba-cc9e-493e-b294-bbd28e69943a.png)

わかること

- rbpから低位アドレスに4バイト低い方向に、0x14が格納されている。イメージ的には下記の図のような感じ、おそらく右か？

![スクリーンショット 2022-07-30 12 39 01](https://user-images.githubusercontent.com/16571394/181871071-d8e13443-4cc2-4ad0-a2cd-cb79302336c4.png)

- stackの大きさに変化なし
- RIPは0x662を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 15. mov eax, DWORD PTR [rbp-0x4] in square

![スクリーンショット 2022-07-30 12 51 28](https://user-images.githubusercontent.com/16571394/181871374-33666fa3-dc90-431c-976b-0fdec0d1b645.png)

わかること

- 特に変化なし、今までで一番変化のないような命令な気がする
- RIPは0x665を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 16. mov esi, eax を実行 in square

![スクリーンショット 2022-07-30 12 56 03](https://user-images.githubusercontent.com/16571394/181871519-15152709-fcf7-48a7-a973-4dfedea1f3e3.png)

わかること

- rsi に0x14 が格納された。おそらくprintfの引数として使用されるのだろう
- stackに大きな変化なし
- RIPは0x667を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 17. lea rdi, [rip+0xc6] を実行 in square

![スクリーンショット 2022-07-30 13 08 05](https://user-images.githubusercontent.com/16571394/181871789-cb3e9e8a-492b-4232-8790-8147874c4346.png)

わかること

- rdi に [rip+0xc6] の値、すなわち0x555555554734が格納される(何のため？)
- stackに大きな変化なし
- RIPは0x66eを指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 18. mov eax, 0x0を実行 in square

![スクリーンショット 2022-07-30 13 13 15](https://user-images.githubusercontent.com/16571394/181871945-ac217d12-36cc-4f06-a4bd-238e0fa43d09.png)

わかること

- raxレジスタをリセットするために、コンパイラが注入したのかしら
- stackに大きな変化なし
- RIPは0x673を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 19. call 0x555555554520 実行 in square

![スクリーンショット 2022-07-30 13 18 03](https://user-images.githubusercontent.com/16571394/181872070-d238fa97-f73f-4535-975a-e3e62b584528.png)

わかること

- print内部の処理の影響か、レジスタの値が変化している
- ベースポインタ/スタックポインタはsquareの関数実行時のもので、特に変わってない（print関数実行時はその辺り変わってたとは思う）
- RIPは0x678を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 20. nop 実行 in square

![スクリーンショット 2022-07-30 13 21 12](https://user-images.githubusercontent.com/16571394/181872187-e2581bbf-5692-4eac-9da8-18d899a542d9.png)


わかること

- gdbのログ上では特に変化は見られない。nopそのものをもう少し知る必要がありそう。
- stackは特に大きな変化なし
- RIPは0x679を指し、次の命令のアドレスを指していそう（逆アセンブルした結果と一致する

#### 21. leave 実行 in square

![スクリーンショット 2022-07-30 13 36 27](https://user-images.githubusercontent.com/16571394/181872559-6a7214aa-10b3-4c8d-901f-602da89067c8.png)

わかること

- stackの領域に変化あり
- まずベースポインタが、b0からd0に変わる。d0はmain関数実行時のベースポインタであった
- そして、スタックポインタが、b8に変更(90からb8へ上位アドレスへの変更となった)
- スタックポインタが指す内容は、main関数に戻った際の、square関数の次に呼び出したい機械語命令のアドレスを指している。
- このb8の内容は、 (9) call square実行時に、rbpを除いた状態である。leaveによって、rbp(b0)まで巻き戻してrbpの値を反映させて、その後それをクリアすることで、b8からがスタックポインタとなった。

#### 22. ret 実行 in square

![スクリーンショット 2022-07-30 13 39 28](https://user-images.githubusercontent.com/16571394/181872660-dffd55b2-a0b8-461b-8f6c-4ba1bf19620e.png)

わかること

- stack領域に変化あり
- スタックポインタが、c0になる。これはsquare関数を呼び出す前（8）の、スタックポインタである。ret命令で解放された。

#### その後

- mainに処理が戻り、main側もret命令になる。
- おそらくmain関数を呼び出している関数も存在するので、mainのスタックメモリを解放しつつそちらに向き先が変わり、処理が完了するのであろう

→ に関して補足

- https://github.com/takeshi-1000/my_memo/blob/main/2022/0729.md#9-call-0x55555555464a-square-%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B-in-main を見ると、0xb8に、呼び出し元関数に復帰した際に読み出したいアドレスが積んである。
- ということは、main関数でも同じことが言えるのでは？
- push時に下から、呼び出し関数で次に読み出したリターンアドレス -> RBPの順に積まれてあるとすると、下記のstackエリアのアドレスの d8(__libc_start_main+231) が、main関数実行後に実行されるところであろう

https://user-images.githubusercontent.com/16571394/181835183-e44bcf20-5c8a-4f17-ac29-b8faa0a4ab28.png


#### メモ

- nopの必要性

→ https://e-words.jp/w/NOP.html 思った通り、基本的には何もしない命令であり、命令一回分の実行時間を確保する意味合いがあるっぽい。

- eaxにいれてstackに入れてeaxに入れてみたいな処理があったようなので、それをもう少し見てみたい
